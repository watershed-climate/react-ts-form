"use strict";var e=require("@hookform/resolvers/zod"),n=require("react"),t=require("react-hook-form"),o=require("zod");function r(e){var n=Object.create(null);return e&&Object.keys(e).forEach((function(t){if("default"!==t){var o=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(n,t,o.get?o:{enumerable:!0,get:function(){return e[t]}})}})),n.default=e,Object.freeze(n)}var i=r(o);const s="_rtf_id";function c(e){return s in e._zod.def}function a(e,n,t,o){return new(t||(t=Promise))((function(n,r){function i(e){try{c(o.next(e))}catch(e){r(e)}}function s(e){try{c(o.throw(e))}catch(e){r(e)}}function c(e){var o;e.done?n(e.value):(o=e.value,o instanceof t?o:new t((function(e){e(o)}))).then(i,s)}c((o=o.apply(e,[])).next())}))}function u(e){let n=e,t=null;for(;n instanceof i.ZodOptional||n instanceof i.ZodNullable||n instanceof i.ZodDefault;)console.log(n,n instanceof i.ZodOptional,n instanceof i.ZodNullable),c(n)&&(t=n._zod.def[s]),(n instanceof i.ZodOptional||n instanceof i.ZodNullable||n instanceof i.ZodDefault)&&(n=n._zod.def.innerType);let o=null;return c(n)&&(o=n._zod.def[s]),{type:n,[s]:o||t}}function d(e){return e instanceof i.ZodPipe?e._zod.def.out instanceof i.ZodTransform?d(e._zod.def.out):e._zod.def.in:e}function l(e,n){const{type:t,_rtf_id:o}=u(e),{type:r,_rtf_id:s}=u(n);if(o||s)return o===s;if(t.constructor!==r.constructor)return!1;if(t instanceof i.ZodArray&&r instanceof i.ZodArray)return!!l(t._zod.def.element,r._zod.def.element);if(t instanceof i.ZodSet&&r instanceof i.ZodSet)return!!l(t._zod.def.valueType,r._zod.def.valueType);if(t instanceof i.ZodMap&&r instanceof i.ZodMap)return!(!l(t._zod.def.keyType,r._zod.def.keyType)||!l(t._zod.def.valueType,r._zod.def.valueType));if(t instanceof i.ZodRecord&&r instanceof i.ZodRecord)return!!l(t._zod.def.valueType,r._zod.def.valueType);if(t instanceof i.ZodTuple&&r instanceof i.ZodTuple){const e=t._def.items,n=r._def.items;if(e.length!==n.length)return!1;for(let t=0;t<e.length;t++)if(!l(e[t],n[t]))return!1;return!0}if(t instanceof i.ZodObject&&r instanceof i.ZodObject){const e=t._zod.def.shape,n=r._zod.def.shape;if(!e||!n)return!e&&!n;const o=Object.keys(e),i=Object.keys(n),s=new Set(o),a=new Set(i);for(const e of i)if(!s.has(e))return!1;for(const e of o)if(!a.has(e))return!1;for(var c of o){const t=e[c],o=n[c];if(!o||!l(t,o))return!1}}return!0}function f(e,n){switch(n){case"ZodString":return e instanceof i.ZodString;case"ZodNumber":return e instanceof i.ZodNumber;case"ZodBoolean":return e instanceof i.ZodBoolean;case"ZodDate":return e instanceof i.ZodDate;case"ZodArray":return e instanceof i.ZodArray;case"ZodObject":return e instanceof i.ZodObject;case"ZodEnum":return e instanceof i.ZodEnum;case"ZodOptional":return e instanceof i.ZodOptional;case"ZodNullable":return e instanceof i.ZodNullable;default:return!1}}const p=o.z.object({}),m=o.z.object({message:o.z.string(),type:o.z.string()});function h(e){if(!function(e){return p.safeParse(e).success}(e))return;if(function(e){return m.safeParse(e).success}(e))return{errorMessage:e.message};const n={};for(const t in e)n[t]=h(e[t]);return n}const b=n.createContext(null);function y({name:e,control:t,children:o,label:r,placeholder:i,enumValues:s,zodType:c,addToCoerceUndefined:a,removeFromCoerceUndefined:u}){return n.createElement(b.Provider,{value:{control:t,name:e,label:r,placeholder:i,enumValues:s,zodType:c,addToCoerceUndefined:a,removeFromCoerceUndefined:u}},o)}function v(e){const t=n.useContext(b);if(!t)throw Error(`${e} must be called from within a FieldContextProvider... if you use this hook, the component must be rendered by @ts-react/form.`);return t}function g(e,n){return`No ${e} found when calling ${n}. Either pass it as a prop or pass it using the zod .describe() syntax.`}function Z(e){const{zodType:n,label:t,placeholder:o}=v(e),r=function(e){const{type:n,_rtf_id:t}=u(e);return{type:n,zodType:e,uniqueId:null!=t?t:void 0,isOptional:e.safeParse(void 0).success,isNullable:e.safeParse(null).success,defaultValue:function(){if(e instanceof i.ZodDefault)return e._zod.def.defaultValue}()}}(n);return Object.assign(Object.assign({},r),{label:t,placeholder:o})}function z(e,n,t){const o=Z(t);const r=function(){const{type:n}=o;if("ZodArray"!==e&&f(n,"ZodArray")){return n.element}return n}();if(!f(r,e))throw new Error(function(e,{expectedType:n,receivedType:t}){return`Make sure that the '${e}' hook is being called inside of a custom form component which matches the correct type.\n  The expected type is '${n}' but the received type was '${t}'`}(t,{expectedType:e,receivedType:r.constructor.name}));return Object.assign(Object.assign({},function(e,n){return Object.entries(n).reduce(((n,[t])=>{const o=e[t];return"string"!=typeof o&&"number"!=typeof o&&"boolean"!=typeof o&&"bigint"!=typeof o&&void 0!==o||(n[t]=o),n}),{})}(r,n)),o)}const O=" // ";function j(e){if(!e)return;const[n,...t]=e.split(O).map((e=>e.trim())),o=t.join(O);return{label:n,placeholder:o||void 0}}function E(e){if(e instanceof i.ZodEnum)return e.options}function _(e){var n;const t=e,o=null===(n=t.meta())||void 0===n?void 0:n.description;return o||("unwrap"in t?_(t.unwrap()):void 0)}function F(e){const n=u(e);return{description:j(_(e)),enumValues:E(n.type)}}const w={duplicateSchema:!1};function T(){var e;w.duplicateSchema||(w.duplicateSchema=!0,e="Found duplicate zod schema in zod-component mapping. Each zod type in the mapping must be unique, if you need to map multiple of the same types to different schemas use createUniqueFieldSchema.",console.warn(`@ts-react/form: ${e}`))}const C=[["name","name"],["control","control"],["enumValues","enumValues"]];const D=e=>e instanceof i.ZodObject,S=e=>e instanceof i.ZodArray;function x(e){return Array.isArray(e)?e.flatMap((e=>x(e))):"object"!=typeof e||null===e||n.isValidElement(e)?[e]:Object.values(e).reduce(((e,n)=>e.concat(x(n))),[])}exports.createTsForm=function(o,r){const i=(null==r?void 0:r.FormComponent)?r.FormComponent:"form",u=o.map((e=>d(e[0])));!function(e){var n=e.flatMap(((n,t)=>e.slice(t+1).map((e=>[n,e]))));for(const[e,t]of n)l(e,t)&&T()}(u),function(e){const n=new Set;for(const t of e)if(c(t)){if(n.has(t._zod.def[s]))throw new Error(`Duplicate id passed to createFieldSchema: ${t._zod.def[s]}. Ensure that each id is only being used once and that createFieldSchema is only called at the top level.`);n.add(t._zod.def[s])}}(u);const f=function(e){const n={};for(const[t,o]of e)n[t]=o;return n}((null==r?void 0:r.propsMap)?r.propsMap:C);return function({schema:r,onSubmit:s,props:c,formProps:u,defaultValues:m,renderAfter:h,renderBefore:b,form:v,children:g}){if(!!n.useRef(v).current!=!!v)throw new Error("useFormResult prop changed - its value shouldn't changed during the lifetime of the component.");const Z=e.zodResolver(r),z=(()=>{if(v)return v;return t.useForm({resolver:Z,defaultValues:m})})();n.useEffect((()=>{v&&m&&v.reset(m)}),[]);const{control:O,handleSubmit:j,setError:E,getValues:_}=z,w=function({resolver:e,onSubmit:t,setError:o}){const r=n.useRef(new Set);function i(e){r.current.add(e)}function s(e){r.current.delete(e)}function c(e){const n=Object.assign({},e);for(const e of r.current)delete n[e];return n}function u(n){return a(this,0,void 0,(function*(){const r=yield e(c(n),{},{}),i="then"in r?yield r:r,s=Object.keys(i.errors);if(s.length)for(const e of s)o(e,i.errors[e]);else yield t(i.values)}))}return{submit:u,removeUndefined:c,removeFromCoerceUndefined:s,addToCoerceUndefined:i}}({resolver:Z,onSubmit:s,setError:E}),T=j(w.submit);function C(e,t,r,i,s){var c,a,u,p,m;const h=d(e),b=function(e,n){for(const t of n)if(l(d(e),d(t[0])))return t[1]}(h,o);if(!b){if(D(h)){const e=h.shape;return Object.entries(e).reduce(((e,[n,o])=>(e[n]=C(o,(null==t?void 0:t[n])?t[n]:void 0,n,`${i}.${n}`,null==s?void 0:s[n]),e)),{})}if(S(h))return(null!==(c=s)&&void 0!==c?c:[]).map(((e,n)=>C(h.element,t,r,`${i}[${n}]`,e)));throw new Error((v=r.toString(),`No matching zod schema for type \`${h._zod.def.type}\` found in mapping for property \`${v}\`. Make sure there's a matching zod schema for every property in your schema.`))}var v;const g=F(h),Z=t&&t[r]?t[r]:{},{beforeElement:z,afterElement:j}=Z,E=Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},f.name&&{[f.name]:i}),f.control&&{[f.control]:O}),f.enumValues&&{[f.enumValues]:g.enumValues}),f.descriptionLabel&&{[f.descriptionLabel]:null===(a=g.description)||void 0===a?void 0:a.label}),f.descriptionPlaceholder&&{[f.descriptionPlaceholder]:null===(u=g.description)||void 0===u?void 0:u.placeholder}),Z),_=null===(p=g.description)||void 0===p?void 0:p.label,T=null===(m=g.description)||void 0===m?void 0:m.placeholder;return n.createElement(n.Fragment,{key:i},z,n.createElement(y,{control:O,name:i,label:_,zodType:h,placeholder:T,enumValues:g.enumValues,addToCoerceUndefined:w.addToCoerceUndefined,removeFromCoerceUndefined:w.removeFromCoerceUndefined},n.createElement(b,Object.assign({key:i},E))),j)}const x=function(e,n){const t=d(e).shape;return Object.entries(t).reduce(((e,[t,o])=>{const r=t.toString();return e[r]=C(o,n,r,r,_()[t]),e}),{})}(r,c);return n.createElement(t.FormProvider,Object.assign({},z),n.createElement(i,Object.assign({},u,{onSubmit:T}),null==b?void 0:b({submit:T}),n.createElement(p,{renderedFields:x,customChildRenderProp:g}),null==h?void 0:h({submit:T})))};function p({customChildRenderProp:e,renderedFields:t}){return n.createElement(n.Fragment,null,e?e(t):x(t))}},exports.createUniqueFieldSchema=function(e,n){return function(e,n){for(const t in n)e._zod.def[t]=n[t];return e}(e,{[s]:n})},exports.useDateFieldInfo=function(){const e=z("ZodDate",{description:!0,maxDate:!0,minDate:!0},"useDateFieldInfo");return Object.assign(Object.assign({},e),{maxDate:e.type.maxDate,minDate:e.type.minDate})},exports.useDescription=function(){const{label:e,placeholder:n}=v("useReqDescription");return{label:e,placeholder:n}},exports.useEnumValues=function(){const{enumValues:e}=v("useEnumValues");if(!e)throw new Error("Enum values not passed. Any component that calls useEnumValues should be rendered from an '.enum()' zod field.");return e},exports.useFieldInfo=function(){return Z("useFieldInfo")},exports.useMaybeFieldName=function(){const e=n.useContext(b);return null==e?void 0:e.name},exports.useNumberFieldInfo=function(){return z("ZodNumber",{description:!0,isFinite:!0,isInt:!0,maxValue:!0,minValue:!0},"useNumberFieldInfo")},exports.useReqDescription=function(){const{label:e,placeholder:n}=v("useReqDescription");if(!e)throw new Error(g("label","useReqDescription"));if(!n)throw new Error(g("placeholder","useReqDescription"));return{label:e,placeholder:n}},exports.useStringFieldInfo=function(){return z("ZodString",{description:!0,isCUID:!0,isCUID2:!0,isDatetime:!0,isEmail:!0,isEmoji:!0,isIP:!0,isULID:!0,isURL:!0,isUUID:!0,maxLength:!0,minLength:!0},"useStringFieldInfo")},exports.useTsController=function(){const e=v("useTsController"),o=t.useController(e),{fieldState:r,field:{onChange:i,value:s}}=o,[c,a]=n.useState(!1);return n.useEffect((()=>{s&&c&&(a(!1),e.removeFromCoerceUndefined(e.name))}),[s]),Object.assign(Object.assign({},o),{error:h(r.error),field:Object.assign(Object.assign({},o.field),{value:c?void 0:o.field.value,onChange:function(n){void 0===n?(a(!0),e.addToCoerceUndefined(e.name)):(a(!1),e.removeFromCoerceUndefined(e.name),i(n))}})})};
